@file:JsExport
package tree.maple.kendec.impl

import tree.maple.kendec.*
import kotlin.js.JsExport
import kotlin.js.JsName
import kotlin.js.JsStatic


// An autogenerated beauty
class StructEndecBuilder {
    companion object {

        @JsStatic
        @JsName("of1")
        fun <S, F1> of(f1: StructField<S, F1>, constructor: (F1) -> S): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor(f1.decodeField(ctx, deserializer, struct))
                }
            }
        }

        @JsStatic
        @JsName("of2")
        fun <S, F1, F2> of(
            f1: StructField<S, F1>,
            f2: StructField<S, F2>,
            constructor: (F1, F2) -> S
        ): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                    f2.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor(
                        f1.decodeField(ctx, deserializer, struct),
                        f2.decodeField(ctx, deserializer, struct)
                    )
                }
            }
        }

        @JsStatic
        @JsName("of3")
        fun <S, F1, F2, F3> of(
            f1: StructField<S, F1>,
            f2: StructField<S, F2>,
            f3: StructField<S, F3>,
            constructor: Function3<F1, F2, F3, S>
        ): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                    f2.encodeField(ctx, serializer, struct, value)
                    f3.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor.apply(
                        f1.decodeField(ctx, deserializer, struct),
                        f2.decodeField(ctx, deserializer, struct),
                        f3.decodeField(ctx, deserializer, struct)
                    )
                }
            }
        }

        @JsStatic
        @JsName("of4")
        fun <S, F1, F2, F3, F4> of(
            f1: StructField<S, F1>,
            f2: StructField<S, F2>,
            f3: StructField<S, F3>,
            f4: StructField<S, F4>,
            constructor: Function4<F1, F2, F3, F4, S>
        ): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                    f2.encodeField(ctx, serializer, struct, value)
                    f3.encodeField(ctx, serializer, struct, value)
                    f4.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor.apply(
                        f1.decodeField(ctx, deserializer, struct),
                        f2.decodeField(ctx, deserializer, struct),
                        f3.decodeField(ctx, deserializer, struct),
                        f4.decodeField(ctx, deserializer, struct)
                    )
                }
            }
        }

        @JsStatic
        @JsName("of5")
        fun <S, F1, F2, F3, F4, F5> of(
            f1: StructField<S, F1>,
            f2: StructField<S, F2>,
            f3: StructField<S, F3>,
            f4: StructField<S, F4>,
            f5: StructField<S, F5>,
            constructor: Function5<F1, F2, F3, F4, F5, S>
        ): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                    f2.encodeField(ctx, serializer, struct, value)
                    f3.encodeField(ctx, serializer, struct, value)
                    f4.encodeField(ctx, serializer, struct, value)
                    f5.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor.apply(
                        f1.decodeField(ctx, deserializer, struct),
                        f2.decodeField(ctx, deserializer, struct),
                        f3.decodeField(ctx, deserializer, struct),
                        f4.decodeField(ctx, deserializer, struct),
                        f5.decodeField(ctx, deserializer, struct)
                    )
                }
            }
        }

        @JsStatic
        @JsName("of6")
        fun <S, F1, F2, F3, F4, F5, F6> of(
            f1: StructField<S, F1>,
            f2: StructField<S, F2>,
            f3: StructField<S, F3>,
            f4: StructField<S, F4>,
            f5: StructField<S, F5>,
            f6: StructField<S, F6>,
            constructor: Function6<F1, F2, F3, F4, F5, F6, S>
        ): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                    f2.encodeField(ctx, serializer, struct, value)
                    f3.encodeField(ctx, serializer, struct, value)
                    f4.encodeField(ctx, serializer, struct, value)
                    f5.encodeField(ctx, serializer, struct, value)
                    f6.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor.apply(
                        f1.decodeField(ctx, deserializer, struct),
                        f2.decodeField(ctx, deserializer, struct),
                        f3.decodeField(ctx, deserializer, struct),
                        f4.decodeField(ctx, deserializer, struct),
                        f5.decodeField(ctx, deserializer, struct),
                        f6.decodeField(ctx, deserializer, struct)
                    )
                }
            }
        }


        @JsStatic
        @JsName("of7")
        fun <S, F1, F2, F3, F4, F5, F6, F7> of(
            f1: StructField<S, F1>,
            f2: StructField<S, F2>,
            f3: StructField<S, F3>,
            f4: StructField<S, F4>,
            f5: StructField<S, F5>,
            f6: StructField<S, F6>,
            f7: StructField<S, F7>,
            constructor: Function7<F1, F2, F3, F4, F5, F6, F7, S>
        ): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                    f2.encodeField(ctx, serializer, struct, value)
                    f3.encodeField(ctx, serializer, struct, value)
                    f4.encodeField(ctx, serializer, struct, value)
                    f5.encodeField(ctx, serializer, struct, value)
                    f6.encodeField(ctx, serializer, struct, value)
                    f7.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor.apply(
                        f1.decodeField(ctx, deserializer, struct),
                        f2.decodeField(ctx, deserializer, struct),
                        f3.decodeField(ctx, deserializer, struct),
                        f4.decodeField(ctx, deserializer, struct),
                        f5.decodeField(ctx, deserializer, struct),
                        f6.decodeField(ctx, deserializer, struct),
                        f7.decodeField(ctx, deserializer, struct)
                    )
                }
            }
        }


        @JsStatic
        @JsName("of8")
        fun <S, F1, F2, F3, F4, F5, F6, F7, F8> of(
            f1: StructField<S, F1>,
            f2: StructField<S, F2>,
            f3: StructField<S, F3>,
            f4: StructField<S, F4>,
            f5: StructField<S, F5>,
            f6: StructField<S, F6>,
            f7: StructField<S, F7>,
            f8: StructField<S, F8>,
            constructor: Function8<F1, F2, F3, F4, F5, F6, F7, F8, S>
        ): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                    f2.encodeField(ctx, serializer, struct, value)
                    f3.encodeField(ctx, serializer, struct, value)
                    f4.encodeField(ctx, serializer, struct, value)
                    f5.encodeField(ctx, serializer, struct, value)
                    f6.encodeField(ctx, serializer, struct, value)
                    f7.encodeField(ctx, serializer, struct, value)
                    f8.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor.apply(
                        f1.decodeField(ctx, deserializer, struct),
                        f2.decodeField(ctx, deserializer, struct),
                        f3.decodeField(ctx, deserializer, struct),
                        f4.decodeField(ctx, deserializer, struct),
                        f5.decodeField(ctx, deserializer, struct),
                        f6.decodeField(ctx, deserializer, struct),
                        f7.decodeField(ctx, deserializer, struct),
                        f8.decodeField(ctx, deserializer, struct)
                    )
                }
            }
        }


        @JsStatic
        @JsName("of9")
        fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9> of(
            f1: StructField<S, F1>,
            f2: StructField<S, F2>,
            f3: StructField<S, F3>,
            f4: StructField<S, F4>,
            f5: StructField<S, F5>,
            f6: StructField<S, F6>,
            f7: StructField<S, F7>,
            f8: StructField<S, F8>,
            f9: StructField<S, F9>,
            constructor: Function9<F1, F2, F3, F4, F5, F6, F7, F8, F9, S>
        ): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                    f2.encodeField(ctx, serializer, struct, value)
                    f3.encodeField(ctx, serializer, struct, value)
                    f4.encodeField(ctx, serializer, struct, value)
                    f5.encodeField(ctx, serializer, struct, value)
                    f6.encodeField(ctx, serializer, struct, value)
                    f7.encodeField(ctx, serializer, struct, value)
                    f8.encodeField(ctx, serializer, struct, value)
                    f9.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor.apply(
                        f1.decodeField(ctx, deserializer, struct),
                        f2.decodeField(ctx, deserializer, struct),
                        f3.decodeField(ctx, deserializer, struct),
                        f4.decodeField(ctx, deserializer, struct),
                        f5.decodeField(ctx, deserializer, struct),
                        f6.decodeField(ctx, deserializer, struct),
                        f7.decodeField(ctx, deserializer, struct),
                        f8.decodeField(ctx, deserializer, struct),
                        f9.decodeField(ctx, deserializer, struct)
                    )
                }
            }
        }


        @JsStatic
        @JsName("of10")
        fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> of(
            f1: StructField<S, F1>,
            f2: StructField<S, F2>,
            f3: StructField<S, F3>,
            f4: StructField<S, F4>,
            f5: StructField<S, F5>,
            f6: StructField<S, F6>,
            f7: StructField<S, F7>,
            f8: StructField<S, F8>,
            f9: StructField<S, F9>,
            f10: StructField<S, F10>,
            constructor: Function10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, S>
        ): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                    f2.encodeField(ctx, serializer, struct, value)
                    f3.encodeField(ctx, serializer, struct, value)
                    f4.encodeField(ctx, serializer, struct, value)
                    f5.encodeField(ctx, serializer, struct, value)
                    f6.encodeField(ctx, serializer, struct, value)
                    f7.encodeField(ctx, serializer, struct, value)
                    f8.encodeField(ctx, serializer, struct, value)
                    f9.encodeField(ctx, serializer, struct, value)
                    f10.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor.apply(
                        f1.decodeField(ctx, deserializer, struct),
                        f2.decodeField(ctx, deserializer, struct),
                        f3.decodeField(ctx, deserializer, struct),
                        f4.decodeField(ctx, deserializer, struct),
                        f5.decodeField(ctx, deserializer, struct),
                        f6.decodeField(ctx, deserializer, struct),
                        f7.decodeField(ctx, deserializer, struct),
                        f8.decodeField(ctx, deserializer, struct),
                        f9.decodeField(ctx, deserializer, struct),
                        f10.decodeField(ctx, deserializer, struct)
                    )
                }
            }
        }

        @JsStatic
        @JsName("of11")
        fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11> of(
            f1: StructField<S, F1>,
            f2: StructField<S, F2>,
            f3: StructField<S, F3>,
            f4: StructField<S, F4>,
            f5: StructField<S, F5>,
            f6: StructField<S, F6>,
            f7: StructField<S, F7>,
            f8: StructField<S, F8>,
            f9: StructField<S, F9>,
            f10: StructField<S, F10>,
            f11: StructField<S, F11>,
            constructor: Function11<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, S>
        ): StructEndec<S> {
            return object : StructEndec<S> {
                override fun encodeStruct(
                    ctx: SerializationContext,
                    serializer: Serializer<*>,
                    struct: StructSerializer,
                    value: S
                ) {
                    f1.encodeField(ctx, serializer, struct, value)
                    f2.encodeField(ctx, serializer, struct, value)
                    f3.encodeField(ctx, serializer, struct, value)
                    f4.encodeField(ctx, serializer, struct, value)
                    f5.encodeField(ctx, serializer, struct, value)
                    f6.encodeField(ctx, serializer, struct, value)
                    f7.encodeField(ctx, serializer, struct, value)
                    f8.encodeField(ctx, serializer, struct, value)
                    f9.encodeField(ctx, serializer, struct, value)
                    f10.encodeField(ctx, serializer, struct, value)
                    f11.encodeField(ctx, serializer, struct, value)
                }

                override fun decodeStruct(
                    ctx: SerializationContext,
                    deserializer: Deserializer<*>,
                    struct: StructDeserializer
                ): S {
                    return constructor.apply(
                        f1.decodeField(ctx, deserializer, struct),
                        f2.decodeField(ctx, deserializer, struct),
                        f3.decodeField(ctx, deserializer, struct),
                        f4.decodeField(ctx, deserializer, struct),
                        f5.decodeField(ctx, deserializer, struct),
                        f6.decodeField(ctx, deserializer, struct),
                        f7.decodeField(ctx, deserializer, struct),
                        f8.decodeField(ctx, deserializer, struct),
                        f9.decodeField(ctx, deserializer, struct),
                        f10.decodeField(ctx, deserializer, struct),
                        f11.decodeField(ctx, deserializer, struct)
                    )
                }
            }
        }
    }

    fun interface Function3<T1, T2, T3, R> {
        fun apply(t1: T1, t2: T2, t3: T3): R
    }

    fun interface Function4<T1, T2, T3, T4, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4): R
    }

    fun interface Function5<T1, T2, T3, T4, T5, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R
    }

    fun interface Function6<T1, T2, T3, T4, T5, T6, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6): R
    }

    fun interface Function7<T1, T2, T3, T4, T5, T6, T7, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7): R
    }

    fun interface Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8): R
    }

    fun interface Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9): R
    }

    fun interface Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10): R
    }

    fun interface Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11): R
    }

    fun interface Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12
        ): R
    }

    fun interface Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12,
            t13: T13
        ): R
    }

    fun interface Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12,
            t13: T13,
            t14: T14
        ): R
    }

    fun interface Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12,
            t13: T13,
            t14: T14,
            t15: T15
        ): R
    }

    fun interface Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12,
            t13: T13,
            t14: T14,
            t15: T15,
            t16: T16
        ): R
    }

    // Here as a one up for using endec... really based though
    fun interface Function17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12,
            t13: T13,
            t14: T14,
            t15: T15,
            t16: T16,
            t17: T17
        ): R
    }
}
