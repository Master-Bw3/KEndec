package tree.maple.kendec.impl

import tree.maple.kendec.Deserializer
import tree.maple.kendec.SerializationContext
import tree.maple.kendec.Serializer
import tree.maple.kendec.StructEndec


// An autogenerated beauty
object StructEndecBuilder {
    fun <S, F1> of(f1: StructField<S, F1>, constructor: (F1?) -> S): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor(f1.decodeField(ctx, deserializer, struct))
            }
        }
    }

    fun <S, F1, F2> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        constructor: (F1?, F2?) -> S
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        constructor: Function3<F1?, F2?, F3?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        constructor: Function4<F1?, F2?, F3?, F4?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        constructor: Function5<F1?, F2?, F3?, F4?, F5?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        constructor: Function6<F1?, F2?, F3?, F4?, F5?, F6?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        constructor: Function7<F1?, F2?, F3?, F4?, F5?, F6?, F7?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7, F8> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        f8: StructField<S, F8>,
        constructor: Function8<F1?, F2?, F3?, F4?, F5?, F6?, F7?, F8?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
                f8.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct),
                    f8.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        f8: StructField<S, F8>,
        f9: StructField<S, F9>,
        constructor: Function9<F1?, F2?, F3?, F4?, F5?, F6?, F7?, F8?, F9?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
                f8.encodeField(ctx, serializer, struct, value)
                f9.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct),
                    f8.decodeField(ctx, deserializer, struct),
                    f9.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        f8: StructField<S, F8>,
        f9: StructField<S, F9>,
        f10: StructField<S, F10>,
        constructor: Function10<F1?, F2?, F3?, F4?, F5?, F6?, F7?, F8?, F9?, F10?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
                f8.encodeField(ctx, serializer, struct, value)
                f9.encodeField(ctx, serializer, struct, value)
                f10.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct),
                    f8.decodeField(ctx, deserializer, struct),
                    f9.decodeField(ctx, deserializer, struct),
                    f10.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        f8: StructField<S, F8>,
        f9: StructField<S, F9>,
        f10: StructField<S, F10>,
        f11: StructField<S, F11>,
        constructor: Function11<F1?, F2?, F3?, F4?, F5?, F6?, F7?, F8?, F9?, F10?, F11?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
                f8.encodeField(ctx, serializer, struct, value)
                f9.encodeField(ctx, serializer, struct, value)
                f10.encodeField(ctx, serializer, struct, value)
                f11.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct),
                    f8.decodeField(ctx, deserializer, struct),
                    f9.decodeField(ctx, deserializer, struct),
                    f10.decodeField(ctx, deserializer, struct),
                    f11.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        f8: StructField<S, F8>,
        f9: StructField<S, F9>,
        f10: StructField<S, F10>,
        f11: StructField<S, F11>,
        f12: StructField<S, F12>,
        constructor: Function12<F1?, F2?, F3?, F4?, F5?, F6?, F7?, F8?, F9?, F10?, F11?, F12?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
                f8.encodeField(ctx, serializer, struct, value)
                f9.encodeField(ctx, serializer, struct, value)
                f10.encodeField(ctx, serializer, struct, value)
                f11.encodeField(ctx, serializer, struct, value)
                f12.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct),
                    f8.decodeField(ctx, deserializer, struct),
                    f9.decodeField(ctx, deserializer, struct),
                    f10.decodeField(ctx, deserializer, struct),
                    f11.decodeField(ctx, deserializer, struct),
                    f12.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        f8: StructField<S, F8>,
        f9: StructField<S, F9>,
        f10: StructField<S, F10>,
        f11: StructField<S, F11>,
        f12: StructField<S, F12>,
        f13: StructField<S, F13>,
        constructor: Function13<F1?, F2?, F3?, F4?, F5?, F6?, F7?, F8?, F9?, F10?, F11?, F12?, F13?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
                f8.encodeField(ctx, serializer, struct, value)
                f9.encodeField(ctx, serializer, struct, value)
                f10.encodeField(ctx, serializer, struct, value)
                f11.encodeField(ctx, serializer, struct, value)
                f12.encodeField(ctx, serializer, struct, value)
                f13.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct),
                    f8.decodeField(ctx, deserializer, struct),
                    f9.decodeField(ctx, deserializer, struct),
                    f10.decodeField(ctx, deserializer, struct),
                    f11.decodeField(ctx, deserializer, struct),
                    f12.decodeField(ctx, deserializer, struct),
                    f13.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        f8: StructField<S, F8>,
        f9: StructField<S, F9>,
        f10: StructField<S, F10>,
        f11: StructField<S, F11>,
        f12: StructField<S, F12>,
        f13: StructField<S, F13>,
        f14: StructField<S, F14>,
        constructor: Function14<F1?, F2?, F3?, F4?, F5?, F6?, F7?, F8?, F9?, F10?, F11?, F12?, F13?, F14?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
                f8.encodeField(ctx, serializer, struct, value)
                f9.encodeField(ctx, serializer, struct, value)
                f10.encodeField(ctx, serializer, struct, value)
                f11.encodeField(ctx, serializer, struct, value)
                f12.encodeField(ctx, serializer, struct, value)
                f13.encodeField(ctx, serializer, struct, value)
                f14.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct),
                    f8.decodeField(ctx, deserializer, struct),
                    f9.decodeField(ctx, deserializer, struct),
                    f10.decodeField(ctx, deserializer, struct),
                    f11.decodeField(ctx, deserializer, struct),
                    f12.decodeField(ctx, deserializer, struct),
                    f13.decodeField(ctx, deserializer, struct),
                    f14.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        f8: StructField<S, F8>,
        f9: StructField<S, F9>,
        f10: StructField<S, F10>,
        f11: StructField<S, F11>,
        f12: StructField<S, F12>,
        f13: StructField<S, F13>,
        f14: StructField<S, F14>,
        f15: StructField<S, F15>,
        constructor: Function15<F1?, F2?, F3?, F4?, F5?, F6?, F7?, F8?, F9?, F10?, F11?, F12?, F13?, F14?, F15?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
                f8.encodeField(ctx, serializer, struct, value)
                f9.encodeField(ctx, serializer, struct, value)
                f10.encodeField(ctx, serializer, struct, value)
                f11.encodeField(ctx, serializer, struct, value)
                f12.encodeField(ctx, serializer, struct, value)
                f13.encodeField(ctx, serializer, struct, value)
                f14.encodeField(ctx, serializer, struct, value)
                f15.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct),
                    f8.decodeField(ctx, deserializer, struct),
                    f9.decodeField(ctx, deserializer, struct),
                    f10.decodeField(ctx, deserializer, struct),
                    f11.decodeField(ctx, deserializer, struct),
                    f12.decodeField(ctx, deserializer, struct),
                    f13.decodeField(ctx, deserializer, struct),
                    f14.decodeField(ctx, deserializer, struct),
                    f15.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        f8: StructField<S, F8>,
        f9: StructField<S, F9>,
        f10: StructField<S, F10>,
        f11: StructField<S, F11>,
        f12: StructField<S, F12>,
        f13: StructField<S, F13>,
        f14: StructField<S, F14>,
        f15: StructField<S, F15>,
        f16: StructField<S, F16>,
        constructor: Function16<F1?, F2?, F3?, F4?, F5?, F6?, F7?, F8?, F9?, F10?, F11?, F12?, F13?, F14?, F15?, F16?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
                f8.encodeField(ctx, serializer, struct, value)
                f9.encodeField(ctx, serializer, struct, value)
                f10.encodeField(ctx, serializer, struct, value)
                f11.encodeField(ctx, serializer, struct, value)
                f12.encodeField(ctx, serializer, struct, value)
                f13.encodeField(ctx, serializer, struct, value)
                f14.encodeField(ctx, serializer, struct, value)
                f15.encodeField(ctx, serializer, struct, value)
                f16.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct),
                    f8.decodeField(ctx, deserializer, struct),
                    f9.decodeField(ctx, deserializer, struct),
                    f10.decodeField(ctx, deserializer, struct),
                    f11.decodeField(ctx, deserializer, struct),
                    f12.decodeField(ctx, deserializer, struct),
                    f13.decodeField(ctx, deserializer, struct),
                    f14.decodeField(ctx, deserializer, struct),
                    f15.decodeField(ctx, deserializer, struct),
                    f16.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    fun <S, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17> of(
        f1: StructField<S, F1>,
        f2: StructField<S, F2>,
        f3: StructField<S, F3>,
        f4: StructField<S, F4>,
        f5: StructField<S, F5>,
        f6: StructField<S, F6>,
        f7: StructField<S, F7>,
        f8: StructField<S, F8>,
        f9: StructField<S, F9>,
        f10: StructField<S, F10>,
        f11: StructField<S, F11>,
        f12: StructField<S, F12>,
        f13: StructField<S, F13>,
        f14: StructField<S, F14>,
        f15: StructField<S, F15>,
        f16: StructField<S, F16>,
        f17: StructField<S, F17>,
        constructor: Function17<F1?, F2?, F3?, F4?, F5?, F6?, F7?, F8?, F9?, F10?, F11?, F12?, F13?, F14?, F15?, F16?, F17?, S>
    ): StructEndec<S> {
        return object : StructEndec<S> {
            override fun encodeStruct(
                ctx: SerializationContext,
                serializer: Serializer<*>,
                struct: Serializer.Struct,
                value: S
            ) {
                f1.encodeField(ctx, serializer, struct, value)
                f2.encodeField(ctx, serializer, struct, value)
                f3.encodeField(ctx, serializer, struct, value)
                f4.encodeField(ctx, serializer, struct, value)
                f5.encodeField(ctx, serializer, struct, value)
                f6.encodeField(ctx, serializer, struct, value)
                f7.encodeField(ctx, serializer, struct, value)
                f8.encodeField(ctx, serializer, struct, value)
                f9.encodeField(ctx, serializer, struct, value)
                f10.encodeField(ctx, serializer, struct, value)
                f11.encodeField(ctx, serializer, struct, value)
                f12.encodeField(ctx, serializer, struct, value)
                f13.encodeField(ctx, serializer, struct, value)
                f14.encodeField(ctx, serializer, struct, value)
                f15.encodeField(ctx, serializer, struct, value)
                f16.encodeField(ctx, serializer, struct, value)
                f17.encodeField(ctx, serializer, struct, value)
            }

            override fun decodeStruct(
                ctx: SerializationContext,
                deserializer: Deserializer<*>,
                struct: Deserializer.Struct
            ): S {
                return constructor.apply(
                    f1.decodeField(ctx, deserializer, struct),
                    f2.decodeField(ctx, deserializer, struct),
                    f3.decodeField(ctx, deserializer, struct),
                    f4.decodeField(ctx, deserializer, struct),
                    f5.decodeField(ctx, deserializer, struct),
                    f6.decodeField(ctx, deserializer, struct),
                    f7.decodeField(ctx, deserializer, struct),
                    f8.decodeField(ctx, deserializer, struct),
                    f9.decodeField(ctx, deserializer, struct),
                    f10.decodeField(ctx, deserializer, struct),
                    f11.decodeField(ctx, deserializer, struct),
                    f12.decodeField(ctx, deserializer, struct),
                    f13.decodeField(ctx, deserializer, struct),
                    f14.decodeField(ctx, deserializer, struct),
                    f15.decodeField(ctx, deserializer, struct),
                    f16.decodeField(ctx, deserializer, struct),
                    f17.decodeField(ctx, deserializer, struct)
                )
            }
        }
    }

    interface Function3<T1, T2, T3, R> {
        fun apply(t1: T1, t2: T2, t3: T3): R
    }

    interface Function4<T1, T2, T3, T4, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4): R
    }

    interface Function5<T1, T2, T3, T4, T5, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R
    }

    interface Function6<T1, T2, T3, T4, T5, T6, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6): R
    }

    interface Function7<T1, T2, T3, T4, T5, T6, T7, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7): R
    }

    interface Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8): R
    }

    interface Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9): R
    }

    interface Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10): R
    }

    interface Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> {
        fun apply(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11): R
    }

    interface Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12
        ): R
    }

    interface Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12,
            t13: T13
        ): R
    }

    interface Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12,
            t13: T13,
            t14: T14
        ): R
    }

    interface Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12,
            t13: T13,
            t14: T14,
            t15: T15
        ): R
    }

    interface Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12,
            t13: T13,
            t14: T14,
            t15: T15,
            t16: T16
        ): R
    }

    // Here as a one up for using endec... really based though
    interface Function17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R> {
        fun apply(
            t1: T1,
            t2: T2,
            t3: T3,
            t4: T4,
            t5: T5,
            t6: T6,
            t7: T7,
            t8: T8,
            t9: T9,
            t10: T10,
            t11: T11,
            t12: T12,
            t13: T13,
            t14: T14,
            t15: T15,
            t16: T16,
            t17: T17
        ): R
    } /*public static void main(String[] args){
        String typesSpot = "{types}";

        String constructorNum = "{cnum}";

        //--

        String typeSpot = "{type}";
        String typeArgumentName = "{arg}";

        String numberSpot = "{num}";

        String structFieldTemplate = "StructField<S, F{num}> f{num}";

        String structFieldArgs = "{fieldArgs}";

        //--

        String structSerCallTemplate = ".field({arg}.name, {arg}.endec, {arg}.getter.apply(value))";

        String structSerCallsSpot = "{serCalls}";

        //--

        //String structDeserCallTemplate = "struct.field({arg}.name, {arg}.endec, {arg}.defaultValue)";
        String structDeserCallTemplate = "{arg}.deserialize(struct)";

        String structDeserCallsSpot = "{deserCalls}";

        String method =
                """
                public static <S, {types}> Endec<S> of({fieldArgs}, Function{cnum}<{types}, S> constructor){
                    return new StructEndec<>() {
                        @Override
                        public void encode(StructSerializer struct, S value) {
                            struct{serCalls};
                        }

                        @Override
                        public S decode(StructDeserializer struct) {
                            return constructor.apply({deserCalls});
                        }
                    };
                }

                """;

        Map<Integer, String> structTypes = new LinkedHashMap<>();
        Map<Integer, String> structArgs = new LinkedHashMap<>();

        Map<Integer, String> structFields = new LinkedHashMap<>();
        Map<Integer, String> structSerCalls = new LinkedHashMap<>();
        Map<Integer, String> structDeserCalls = new LinkedHashMap<>();

        String allMethods = "";

        for (int i = 1; i < 17; i++) {
            structTypes.put(i, "F" + i);
            structArgs.put(i, "f" + i);

            structFields.put(i, structFieldTemplate.replace(numberSpot, String.valueOf(i)));
            structSerCalls.put(i, structSerCallTemplate.replace(typeArgumentName, structArgs.get(i)));
            structDeserCalls.put(i, structDeserCallTemplate.replace(typeArgumentName, structArgs.get(i)));

            String types = String.join(", ", structTypes.values());

            String fieldArgs = String.join(", ", structFields.values());

            String serCalls = String.join("\n", structSerCalls.values());
            String deserCalls = String.join(",\n", structDeserCalls.values());

            String newMethod = method
                    .replace(constructorNum, String.valueOf(i))
                    .replace(typesSpot, types)
                    .replace(structFieldArgs, fieldArgs)
                    .replace(structSerCallsSpot, serCalls)
                    .replace(structDeserCallsSpot, deserCalls);

            allMethods = allMethods.concat(newMethod);
        }

        try(FileWriter myWriter = new FileWriter("test.txt")) {
            myWriter.write(allMethods);
        } catch (IOException e){
            throw new RuntimeException(e);
        }
    }*/
}
